[
  {
    "name": "Media.Events",
    "comment": " ###Events\n\n@docs onPlaying, onPaused, onTimeUpdate, onDurationChange, onEnded, onAbort, onSeeked, onSeeking, onLoadStart, onLoadedMetadata, onLoadedData, onLoadSuspend, onEmptied, onWaiting, onStalled, onProgress, onCanPlay, onCanPlayThrough, onError\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "onAbort",
        "comment": " Triggered when the playback of media is aborted (such as restarting it)\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onCanPlay",
        "comment": " Triggered when enough data has been loaded to begin playback of the media,\nbut not enough has yet been loaded to play all the way to the end without pausing to\nbuffer.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onCanPlayThrough",
        "comment": " Triggered when enough data has been loaded to playback the file to the end.\n**NOTE: This event does mean the whole media file has been buffered, only that enough\nhas been buffered that if the current download rate is continued, it will be finished\nfast enough that the user will never have to wait.\n\n** NOTE: Also fired on a toggle of play/pause **\n\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onDurationChange",
        "comment": " Triggered when the duration of a media file changes.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onEmptied",
        "comment": " Triggered when the media has become empty, such as if the load task\nis invoked.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onEnded",
        "comment": " Triggered when playback completes\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onError",
        "comment": " Triggered when a media Error occurs.\n** NOTE: These are errors from the native playr of the browser, not errors\ngenerated by this package. **\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onLoadStart",
        "comment": " Triggered when the loading of the media has begun.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onLoadSuspend",
        "comment": " Triggered when the loading of the media is suspended for any reason (including\nbecause it has finished downloading\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onLoadedData",
        "comment": " Triggered when the media's first frame or sample has finished loading.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onLoadedMetadata",
        "comment": " Triggered when the media's metadata has been completely loaded.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onPaused",
        "comment": " Triggered when the media is paused\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onPlaying",
        "comment": " Triggered when playback begins\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onProgress",
        "comment": " Triggered periodically to provide updates on the download progress of\nthe media.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onSeeked",
        "comment": " Triggered when a player finishes seeking\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onSeeking",
        "comment": " Triggered when a player begins seeking\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onStalled",
        "comment": " Fired when the loading of the media stalls, that is, when the browser is trying\nto fetch media data, but it is not forthcoming.\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onTimeUpdate",
        "comment": " Triggered when the currentTime of the player has changed.\n** NOTE: This doesn't occur on a per frame basis. For performance reasons,\nsome browsers only trigger this event every so often, as infrequently as ever 250ms\nin some cases. **\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      },
      {
        "name": "onWaiting",
        "comment": " Sent when a task is waiting on the completion of another task (such as Play having\nto wait until Seek is complete).\n",
        "type": "(Media.State.State -> msg) -> Html.Attribute msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Media",
    "comment": " This is an experimental attempt to wrap the HTML5 Media API,\nmaking it possible to write more sophisticated audio and video players\nin Elm. Let me reiterate, this is experiemental, and not ready\nfor production. Use at your peril.\n\nThis package is a fairly direct layer over the Media API. I'm all for higher\nlevel abstractions, but when dealing with media, a player _is_ the abstraction.\nThis package will hopefully allow myself and others to write great players that\nabstract away the annoying details of dealing with audio & video. I've also\npublished an example of such a player here: (INSERT LINK ONCE PUBLISHED)\n\nThis package uses native code for a set of tasks that control playback\nof media (Play, Pause, Load, Seek, etc) and to get the current state of\nthe media (Media.State.now) and also to check if a the browser supports\na given filetype (canPlayType).\n\nIt also uses native code to decode TimeRanges objects (which cannot be accessed\nvia an array syntax and therefore cannot be decoded currently in pure Elm).\n\nAside from the basic playback tasks, the heart of this library is a Json decoder that\ntakes an HtmlMediaElement's state and decodes it to an Elm record, as well as a set\nof events that return a (Media.State.State -> Msg) so you can update your model\nwhenever these events fire. Also, there's a subscription for getting the state every\nanimation frame, in case you need a more frame accurate result, but this comes\nwith a performance penalty, and most great javascript media players simply rely on the\nevents, so I don't recommend.\n\nFour important parts of writing players are not wrapped by this library:\n\n1.  Subtitles - These are very important and are the next thing on my list to implement,\n    I just need to figure out the cross-browser issues first. I'm very sensitive to the needs\n    of hearing impaired users, so this is a top priority.\n\n2.  Media Source Extensions - This is a portion of the Media API that allows us to do live\n    streaming and adaptibe bitrate media. I think I have a good design for it, but it's a big\n    challenge, and I want to make sure people like the API design of the basic Media API first.\n\n3.  Web Audio - Web Audio API is often used to calculate the waveforms of audio files in\n    audio players. However, wrapping that part of the Web API is beyond the scope of this package.\n    Use ports for now. If this package gains acceptance and use, I'll commit to doing Web Audio\n    as well.\n\n4.  Fullscreen API - This is a pretty necessary Web API for writing a proper video player,\n    but it beyond the scope of this package (besides, smarter people are working on this).\n\nBut as long as you're not planning to display subtitles, do live streaming (or Adaptive Bitrate),\ngenerate waveforms or make a video fullscreen, this package should be ready to go.\n\nThis is a 1.0.0, and I'd love your feedback.\n\n\n### Helpers\n\n@docs muted, playbackRate, timeToString, playbackToString\n\n\n### Media Control\n\n@docs play, pause, load, fastSeek, seek\n\n\n### canPlayMedia\n\n@docs canPlayType, CanPlay\n\n\n### Elm-Media Errors\n\n@docs Error\n\n",
    "aliases": [
      {
        "name": "Error",
        "comment": " These are errors thrown by the tasks defined in this module.\n\nNotFound: No element with that Id was found. Returns the Id provided\nNotMediaElement: The element found with that Id was not an HTMLMediaElement. Returns the Id provided and the constructor of the element found with that id\nPlayPromiseFailure: On modern browsers, Play() returns a promise.\n\n",
        "args": [],
        "type": "Media.State.Error"
      }
    ],
    "types": [
      {
        "name": "CanPlay",
        "comment": " These are the three possible results of canPlayType.\n\nProbably: This source is probably a playable type (probably because media can have all sorts of problem and browser support is all over the place)\nMaybe: The player can try to play the media, but until it does, it has no idea where it will play or not\nNo: The media definitely cannot be played\n\n",
        "args": [],
        "cases": [
          [
            "Probably",
            []
          ],
          [
            "Maybe",
            []
          ],
          [
            "No",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "canPlayType",
        "comment": " Tries to find a media element by Id and test if it can a given MIME-type, provided as a String.\n",
        "type": "Media.State.Id -> String -> Task.Task Media.Error Media.CanPlay"
      },
      {
        "name": "fastSeek",
        "comment": " Take an Id and Time, find a media element and change the playback position to the provided Time. Gives up some precision (compared to setting currentTime to desired seek value) for speed. Can fail if the Id isn't found or it isn't an HTMLMediaElement.\n",
        "type": "Media.State.Id -> Time.Time -> Task.Task Media.Error ()"
      },
      {
        "name": "load",
        "comment": " Tries to take an Id, finds a media element and resets it. Can fail if the Id isn't found or it isn't an HTMLMediaElement.\n",
        "type": "Media.State.Id -> Task.Task Media.Error ()"
      },
      {
        "name": "muted",
        "comment": " A helper function for easily setting the muted property on a media element.\n\n    player =\n        audio [ id \"player1\", controls True, muted False, src \"audiofile.mp3\" ]\n            []\n\n",
        "type": "Bool -> Html.Attribute msg"
      },
      {
        "name": "pause",
        "comment": " Tries to take an Id switch it to a Paused state of Playback. Can fail if the Id isn't found or it isn't an HTMLMediaElement.\n",
        "type": "Media.State.Id -> Task.Task Media.Error ()"
      },
      {
        "name": "play",
        "comment": " Tries to take an Id and switch it to a Playing state of Playback. Can fail if the Id isn't found, isn't an HTMLMediaElement, or fails to play.\n",
        "type": "Media.State.Id -> Task.Task Media.Error ()"
      },
      {
        "name": "playbackRate",
        "comment": " A helper function for easily setting the muted property on a media element.\n\n    player =\n        audio [ id \"player1\", controls True, muted False, src \"audiofile.mp3\" ]\n            []\n\n",
        "type": "Float -> Html.Attribute msg"
      },
      {
        "name": "playbackToString",
        "comment": " Takes a Playback type and returns a nicely formatted string\n",
        "type": "Media.State.Playback -> String"
      },
      {
        "name": "seek",
        "comment": " Tries to take an Id and Time, find a media element and change the playback position to the provided Time. Can fail if the Id isn't found or it isn't an HTMLMediaElement.\n",
        "type": "Media.State.Id -> Time.Time -> Task.Task Media.Error ()"
      },
      {
        "name": "timeToString",
        "comment": " Converts a time value, such as a currentTime or duration, and returns a nicely\nformatted string. Values of NaN or infinity will return 0:00.\n\nIt will always return a single-digit minute place and double-digit second place.\nIt will automatically format the minutes to two digits when necessary\n\n",
        "type": "Float -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Media.State",
    "comment": " This module provides definitions for types representing the state of an HTMLMediaElement. I provided as few details as I could, and figure out as much for a user as possible, but players are complicated, and require a lot of information to do different things. It's likely that no player will need to simultaneously use all the fields I've exposed, and it's likely that most will never need more than a few, like duration, volume, currentTime, etc.\n\nMedia is constantly updating itself, without user interaction--which is to say, it has side effects. This library deals with those side effects by providing a subscription to those side effects.\n\nYou can also use decode to transform a value representing an HTMLMediaElement into a State.\n\n###State\n\n@docs State, default, defaultAudio, defaultVideo\n\n###Getting and Decoding State\n\n@docs everyFrame, now, state\n\n###State Types\n\n@docs Id, MediaType, Playback\n@docs MediaError, ReadyState, NetworkState\n@docs TimeRange, Error, VideoSize\n\n",
    "aliases": [
      {
        "name": "Id",
        "comment": " String representing the Dom id of your media element.\n\n**Important:** Please, please, please use unique Id's for your media elements. We use the Id to find the element to run Tasks like play, load, and getState. Media.Events events also currently return an Id. Please let them be unique.\n\n",
        "args": [],
        "type": "String"
      },
      {
        "name": "State",
        "comment": " The core record of the media library. This represents the state of an HTMLMediaElement at a given moment. getState and subscribe both return a state record. In other words, this is a record representing the current state of side effects on a media object.\n\nYou can put this in your model or create a simpler abstraction with just the fields you need, such as:\n\ntype alias Model =\n{ id: String\n, currentTime: Float\n, duration: Float\n}\n\nThen in your update function, just update the fields you need with the fields from the State:\n\ntype Msg\n= Media.State.State\n\nupdate model msg =\ncase msg of\nMediaUpdate state ->\n({ model | currentTime = state.currentTime\n, duration = state.duration }\n,\nCmd.none )\n\n**Important:** Please make sure to give your audio and video elements a unique Id.\n\n**NOTE: Most browsers will not return a duration of infinity during a live stream, use the \"seekable\" TimeRange instead.\n\n",
        "args": [],
        "type": "{ id : Media.State.Id , mediaType : Media.State.MediaType , playback : Media.State.Playback , source : String , currentTime : Time.Time , duration : Time.Time , data : Media.State.DataGroup , timeRanges : Media.State.TimeGroup , videoSize : { width : Int, height : Int } }"
      },
      {
        "name": "TimeRange",
        "comment": " Represents a start and end time within the duration of the media source. Does not necessarily (or usually) represent the duration of the media source itself.\n\nExamples include the sections of a media source that are buffered, the sections that are seekable, etc.\n\n",
        "args": [],
        "type": "{ start : Time.Time, end : Time.Time }"
      },
      {
        "name": "VideoSize",
        "comment": " Represents the size of video media\n",
        "args": [],
        "type": "{ width : Int, height : Int }"
      }
    ],
    "types": [
      {
        "name": "Error",
        "comment": " These are the errors of this library, that may be returned when calling a task\nor decoding a state.\n",
        "args": [],
        "cases": [
          [
            "NotFound",
            [
              "String"
            ]
          ],
          [
            "NotMediaElement",
            [
              "String",
              "String"
            ]
          ],
          [
            "PlayPromiseFailure",
            [
              "String"
            ]
          ],
          [
            "NotTimeRanges",
            [
              "String"
            ]
          ],
          [
            "DecodeError",
            [
              "String"
            ]
          ]
        ]
      },
      {
        "name": "MediaError",
        "comment": " These are the errors the media player itself might throw. The errors include a human readable string with specific diagnostic information, passed from the browser itself.\n\nAborted: Fetching of the media resource was aborted by user request\nNetwork: A Network error occured that prevented the browser from fetching the media, despite it having been previously available\nDecode: The browser is unable to decode the media, despite it previously having been supported\nUnsupported: The resource or media provider object is not supported or is otherwise unsuitable\n\n",
        "args": [],
        "cases": [
          [
            "Aborted",
            [
              "String"
            ]
          ],
          [
            "Network",
            [
              "String"
            ]
          ],
          [
            "Decode",
            [
              "String"
            ]
          ],
          [
            "Unsupported",
            [
              "String"
            ]
          ]
        ]
      },
      {
        "name": "MediaType",
        "comment": " ",
        "args": [],
        "cases": [
          [
            "Audio",
            []
          ],
          [
            "Video",
            []
          ]
        ]
      },
      {
        "name": "NetworkState",
        "comment": " Represents the four possible states of a media player loading\ndata from the media file:\n\nEmpty: No data yet. ReadyState is HaveNothing\nIdle: Media Element is active and has a resource, but is not currently using the network to load it|\nLoading: Media Element is currently downloading data\nNoSource: No Media Element Source found\n\n",
        "args": [],
        "cases": [
          [
            "Empty",
            []
          ],
          [
            "Idle",
            []
          ],
          [
            "DataLoading",
            []
          ],
          [
            "NoSource",
            []
          ]
        ]
      },
      {
        "name": "Playback",
        "comment": " Current Playback state of the media player. Error represents a MediaError, thrown by the browser, not an Error thrown by the tasks in this module.\n",
        "args": [],
        "cases": [
          [
            "Paused",
            []
          ],
          [
            "Playing",
            []
          ],
          [
            "Loading",
            []
          ],
          [
            "Buffering",
            []
          ],
          [
            "Ended",
            []
          ],
          [
            "Problem",
            [
              "Media.State.MediaError"
            ]
          ]
        ]
      },
      {
        "name": "ReadyState",
        "comment": " Representation of the ReadyState of Media data, which indicates when it will be ready to play.\n\nHaveNothing: No information is available about the media resource\nHaveMetadata: Enough information is available that metadata attributes are initialized.\nHaveCurrentData: Enough data is available to play the current frame, but only the current frame.\nHaveFutureData: Data beyond the current frame is available, but not the entire source. May be as little as two frames.\nHaveEnoughData: Enough data is available that if downloading continues at current data rate, user will be able to play until the end of the source without interruption\n\n",
        "args": [],
        "cases": [
          [
            "HaveNothing",
            []
          ],
          [
            "HaveMetadata",
            []
          ],
          [
            "HaveCurrentData",
            []
          ],
          [
            "HaveFutureData",
            []
          ],
          [
            "HaveEnoughData",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "default",
        "comment": " Returns a default state, given an id, a mediaType (Audio or Video),\nand a Maybe source. This can be thought of as empty player state, for\nputting in your init, if the media isn't loaded.\n",
        "type": "{ id : Media.State.Id , mediaType : Media.State.MediaType , source : Maybe.Maybe String } -> Media.State.State"
      },
      {
        "name": "defaultAudio",
        "comment": " Returns a default state for an Audio player, with source \"\".\nJust give it an id.\n",
        "type": "Media.State.Id -> Media.State.State"
      },
      {
        "name": "defaultVideo",
        "comment": " Returns a default state for a Video player, with source \"\".\nJust give it an id.\n",
        "type": "Media.State.Id -> Media.State.State"
      },
      {
        "name": "everyFrame",
        "comment": " **Very Important -- Not Yet Implemented -- Do Not Use**\n\nA media element has many attributes that will update themselves without any user input. This is a serious side-effect. This function lets you subscribe to its current State, delivered with each Animation Frame, via requestAnimationFrame().\n\n    main =\n        Html.Program\n            { init = init\n            , view = view\n            , update = update\n            , subscriptions = subscription\n            }\n\n        subscription = Media.subscribe \"audioPlayer\" updateMediaState\n\nYou can also get these updates using getState after a variety of events in Media.Events, but subscription should be your prefered way to keep track of the side effects.\n\n",
        "type": "Media.State.Id -> (Result.Result Media.State.Error Media.State.State -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "now",
        "comment": " Takes an Id, and returns the State of a mediaElement with that id.\nCan result in Error if the Id is not found, or the element found by that\nid isn't an HTMLMediaElement.\n",
        "type": "Media.State.Id -> Task.Task Media.State.Error Media.State.State"
      },
      {
        "name": "state",
        "comment": " Decodes the current state of an HtmlMediaElement\n",
        "type": "Json.Decode.Decoder Media.State.State"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]